import glob
import random
from collections import defaultdict
from dataclasses import dataclass
from operator import itemgetter
from os.path import exists
from typing import Tuple, List, Set

from monai.data import PILReader
from monai.transforms import Compose, LoadImaged, AddChanneld
from pydantic import BaseModel, Extra
from zeus.utils import named_match, read_json
from zeus.utils.collections import NamedList

from kidney.datasets.transformers import Transformers

DEFAULT_REGEX = (
    r'(?P<key>[\w\d]+)\.'
    r'(?P<dx>\d+)\.'
    r'(?P<dy>\d+)\.'
    r'(?P<stride>\d+)'
)


def read_masked_images(
    folder: str,
    image_prefix: str = 'img',
    mask_prefix: str = 'seg',
    file_regex: str = DEFAULT_REGEX,
    image_extension: str = 'png'
) -> NamedList:
    """Collects images and segmentation masks from folder.

    Parameters
    ----------
    folder
        Local folder with image files.
    image_prefix
        Image filename prefix.
    mask_prefix
        Segmentation mask filename prefix.
    file_regex
        Regular expression used to discover samples. Filenames that don't match are ignored.
    image_extension
        Image extension.

    Returns
    -------
    NamedList:
        The named list of (key, value) samples where key is sample's identifier, and
        value is a dictionary with meta-information about sample and file paths to image
        and its mask.

    """
    images_info = defaultdict(dict)

    for suffix in (image_prefix, mask_prefix):
        pattern = rf'{suffix}\.{file_regex}\.{image_extension}'

        for path in glob.glob(f'{folder}/{suffix}.*.{image_extension}'):
            m = named_match(pattern, path)
            key, dx, dy = m['key'], m['dx'], m['dy']
            identifier = f'{key}.{dx}.{dy}'
            images_info[identifier][
                'mask'
                if suffix == mask_prefix
                else 'image'
            ] = path
            images_info[identifier]['position'] = dx, dy
            images_info[identifier]['key'] = key

    sorted_keys = map(
        itemgetter(0),
        sorted(images_info.items(), key=itemgetter(0))
    )

    return NamedList([(key, images_info[key]) for key in sorted_keys])


class SegmentationSample(BaseModel):
    image_path: str
    mask_path: str
    position: Tuple[int, int]
    image_shape: List[int]
    source_key: str
    relevant: bool = True

    class Config:
        extra = Extra.allow


def read_masked_images_from_json(
    json_file: str,
    relevant_only: bool = True
) -> List[SegmentationSample]:
    """Reads information about masked images from JSON file.

    A JSON file is expected to be generated by bin/histogram.py script that analyzes
    patches extracted from TIFF images and builds a meta-data file.

    Parameters
    ----------
    json_file
        Path to JSON file with meta-information about samples, including paths
        to images and masks
    relevant_only
        If True, then only samples with "relevant" flag set are included into list
        of results. If the field is not present, a sample is considered to be relevant.

    Returns
    -------
    samples
        The list of segmentation samples.

    """
    assert exists(json_file), f"meta-data file does not exist: {json_file}"
    items = read_json(json_file)
    samples = []
    for item in items:
        if relevant_only and not item.get("relevant", True):
            continue
        m = named_match(DEFAULT_REGEX, item["image"])
        if not m:
            continue
        sample = SegmentationSample(
            image_path=item["image"],
            mask_path=item["mask"],
            position=item["position"],
            image_shape=item["image_shape"],
            source_key=m["key"],
            relevant=item.get("relevant", True)
        )
        samples.append(sample)
    return samples


@dataclass
class SegmentationData:
    image_key: str
    mask_key: str
    train_keys: Set[str]
    valid_keys: Set[str]
    train: List[SegmentationSample]
    valid: List[SegmentationSample]


def read_segmentation_data_from_json(
    json_file: str,
    relevant_only: bool = True,
    train_keys: Set[str] = None,
) -> SegmentationData:
    samples = read_masked_images_from_json(json_file, relevant_only)
    source_keys = {sample.source_key for sample in samples}

    if train_keys is not None:
        missing_keys = train_keys.difference(source_keys)
        assert not missing_keys, f"training keys are not found: {missing_keys}"
        valid_keys = {key for key in source_keys if key not in train_keys}
    else:
        valid_keys = {random.choice(list(source_keys))}
        train_keys = {key for key in source_keys if key not in valid_keys}

    assert train_keys != valid_keys and train_keys and valid_keys, "wrong keys setup"

    train_samples, valid_samples = [], []
    for sample in samples:
        subset = (
            train_samples
            if sample.source_key in train_keys
            else valid_samples
        )
        subset.append(sample)

    return SegmentationData(
        image_key="image_path",
        mask_key="mask_path",
        train_keys=train_keys,
        valid_keys=valid_keys,
        train=train_samples,
        valid=valid_samples
    )


def main():
    json_file = "/mnt/fast/data/kidney_patches/histograms.json"
    data = read_segmentation_data_from_json(json_file)
    print(data)


if __name__ == '__main__':
    main()
